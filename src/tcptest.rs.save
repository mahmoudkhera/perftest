use crate::messages_handler::StreamData;
use crate::test_utils::TestParameters;
use crate::ui;
use anyhow::Result;
use anyhow::bail;
use log::info;
use std::convert::TryInto;
use std::fmt::Debug;
use std::time::Duration;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::sync::mpsc::{Receiver, Sender};
use tokio::task::JoinHandle;
use tokio::time::Instant;

#[derive(Debug, Clone)]
pub enum StreamMessage {
    StartTest,
    Terminate,
}

pub struct StreamHandle {
    pub stream_sender: Sender<StreamMessage>,
    pub task_handle: JoinHandle<Result<StreamData>>,
}

pub struct StreamTester {
    id: usize,
    stream: TcpStream,
    params: TestParameters,
    is_sending: bool,
    reciver: Receiver<StreamMessage>,
}

impl StreamTester {
    pub fn new(
        id: usize,
        stream: TcpStream,
        params: TestParameters,
        is_sending: bool,
        reciver: Receiver<StreamMessage>,
    ) -> Self {
        StreamTester {
            id,
            stream,
            params,
            is_sending,
            reciver,
        }
    }

    pub async fn run_test(mut self) -> Result<StreamData> {
        let block_size = self.params.block_size;
        let mut buffer = vec![0u8; block_size];

        fill_random(&mut buffer, self.is_sending).await;

       
        self.configure_stream_socket()?;
        //what unntil the StartTst message is recived from the controler
        let signal = self.reciver.recv().await;

        if !matches!(signal, Some(StreamMessage::StartTest)) {
            bail!("Internal communication channel for stream was terminated unexpectedly!");
        }

        info!("measuring....");

        let start_time = Instant::now();
        let timeout = Duration::from_secs(self.params.time_seconds);
        let interval = Duration::from_secs(1);

        let mut bytes_transferred = 0usize;
        let mut syscalls = 0usize;

        let mut interval_start = Instant::now();
        let mut interval_bytes = 0usize;
        let mut interval_syscalls = 0usize;

        loop {
            if start_time.elapsed() > timeout {
                break;
            }

            match self.reciver.try_recv() {
                Ok(StreamMessage::Terminate) => break,
                Ok(StreamMessage::StartTest) => {
                    println!("Stream {}: duplicate StartTest received", self.id);
                }

                _ => {}
            }

            if self.is_sending {
                match tokio::time::timeout(Duration::from_millis(100), self.stream.write(&buffer))
                    .await
                {
                    Ok(Ok(0)) => {
                        println!("the connection is closed");
                        break;
                    }
                    Ok(Ok(n)) => {
                        bytes_transferred += n;
                        interval_bytes += n;
                        syscalls += 1;
                        interval_syscalls += 1;
                    }

                    Err(_) => {
                        println!("Stream {}: write timeout (>100ms)", self.id);
                    }
                    _ => {}
                }
            } else {
                match tokio::time::timeout(
                    Duration::from_millis(100),
                    self.stream.read(&mut buffer),
                )
                .await
                {
                    Ok(Ok(0)) => {
                        println!("reach EOF");
                        break;
                    }
                    Ok(Ok(n)) => {
                        bytes_transferred += n;
                        interval_bytes += n;
                        syscalls += 1;
                        interval_syscalls += 1;
                    }

                    Err(_) => {
                        println!("Stream {}: read timeout (>100ms)", self.id);
                    }
                    _ => {}
                }
            }

            let now = Instant::now();
            let current_interval = now - interval_start;

            if current_interval >= interval {
                ui::print_stats(
                    Some(self.id),
                    (start_time.elapsed() - interval)
                        .as_millis()
                        .try_into()
                        .unwrap(),
                    current_interval.as_millis().try_into().unwrap(),
                    interval_bytes,
                    self.is_sending,
                    interval_syscalls,
                    block_size,
                );
                interval_start = now;
                interval_bytes = 0;
                interval_syscalls = 0;
            }
        }

        if !self.is_sending {
            while self.stream.read(&mut buffer).await? != 0 {}
        }
        Ok(StreamData {
            sender: self.is_sending,
            duration_millis: start_time.elapsed().as_millis() as u64,
            bytes_transferred,
            syscalls,
        })
    }

    fn configure_stream_socket(&mut self) -> Result<()> {
        //set tcp no delay if requested
        if self.params.no_delay {
            self.stream.set_nodelay(true)?;
        }

        if let Some(buferr_size) = self.params.socket_buffer {
            let buf_size = buferr_size.try_into().unwrap_or(u32::MAX);

            // SAFETY: This is safe because we don't use the TcpSocket after this point.
            #[cfg(any(unix, windows))]
            unsafe {
                let sock = {
                    #[cfg(unix)]
                    {
                        use std::os::unix::io::{AsRawFd, FromRawFd};

                        tokio::net::TcpSocket::from_raw_fd(self.stream.as_raw_fd())
                    }
                    #[cfg(windows)]
                    {
                        use std::os::windows::io::{AsRawSocket, FromRawSocket};
                        tokio::net::TcpSocket::from_raw_socket(self.stream.as_raw_socket())
                    }
                };

                sock.set_recv_buffer_size(buf_size)
                    .unwrap_or_else(|err| println!("set_recv_buffer_size(), error: {}", err));
                sock.set_send_buffer_size(buf_size)
                    .unwrap_or_else(|err| println!("set_send_buffer_size(), error: {}", err));
            }
       
} 
 
fn set_mss(stream: tokio::net::TcpStream, mss: u32) -> tokio::net::cst IPPROTO_TCP: i32 = 6; // always 6 for TCP
    const TCP_MAXSEG: i32 = 2; // Linux/BSD: max segment size option

    #[cfg(target_os = "linux")]
    {
        use std::os::fd::AsRawFd;
        let fd = stream.stream.as_raw_fd();
        let ret = unsafe {
            libc::setsockopt(
                fd,                              

 async fn fill_random(buffer: &mut [u8], sending: bool) {
    if sending {
        use rand::Rng;
        rand::thread_rng().fill(&mut buffer[..]);
    }
